name: ğŸ“š Auto-Documentation

on:
  push:
    branches: [ main, develop ]
    paths:
      - 'src/**/*.py'
      - 'tests/**/*.py'
      - 'mcp_server.py'
      - 'requirements.txt'
      - '*.md'
  pull_request:
    branches: [ main ]
    paths:
      - 'src/**/*.py'
      - 'tests/**/*.py'
      - 'mcp_server.py'
      - 'requirements.txt'
  workflow_dispatch:
    inputs:
      force_update:
        description: 'Force documentation update'
        required: false
        default: 'false'
        type: boolean

jobs:
  auto-documentation:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
      
    steps:
    - name: ğŸ”„ Checkout Code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        token: ${{ secrets.GITHUB_TOKEN }}
    
    - name: ğŸ Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'
        cache: 'pip'
    
    - name: ğŸ” Validate Requirements
      run: |
        echo "ğŸ” Validating requirements.txt..."
        
        if [ ! -f "requirements.txt" ]; then
          echo "âŒ requirements.txt not found!"
          exit 1
        fi
        
        echo "ğŸ“‹ Requirements file contents:"
        cat requirements.txt
        
        echo "ğŸ” Checking for duplicates..."
        if [ $(cat requirements.txt | grep -v '^#' | grep -v '^$' | sort | uniq -d | wc -l) -gt 0 ]; then
          echo "âš ï¸ Duplicate entries found:"
          cat requirements.txt | grep -v '^#' | grep -v '^$' | sort | uniq -d
        else
          echo "âœ… No duplicate entries found"
        fi
        
        echo "ğŸ“Š Total dependencies: $(cat requirements.txt | grep -v '^#' | grep -v '^$' | wc -l)"
    
    - name: ğŸ“¦ Install Dependencies
      run: |
        echo "ğŸ” Debug: Python and pip versions"
        python --version
        pip --version
        
        echo "ğŸ“¦ Upgrading pip..."
        python -m pip install --upgrade pip
        
        echo "ğŸ“‹ Installing dependencies from requirements.txt..."
        pip install -r requirements.txt
        
        echo "âœ… Dependencies installed successfully"
        echo "ğŸ” Installed packages:"
        pip list | grep -E "(watchdog|GitPython|fastapi|scikit-learn)"
    
    - name: ğŸ” Analyze Project Structure
      id: analyze
      run: |
        echo "ğŸ“Š Analyzing project structure..."
        
        # Count source files
        SRC_FILES=$(find src -name "*.py" | wc -l)
        TEST_FILES=$(find tests -name "*.py" 2>/dev/null | wc -l)
        TOTAL_LINES=$(find src -name "*.py" -exec wc -l {} + | tail -1 | awk '{print $1}')
        
        echo "src_files=$SRC_FILES" >> $GITHUB_OUTPUT
        echo "test_files=$TEST_FILES" >> $GITHUB_OUTPUT
        echo "total_lines=$TOTAL_LINES" >> $GITHUB_OUTPUT
        
        echo "ğŸ“ˆ Project Stats:"
        echo "  - Source files: $SRC_FILES"
        echo "  - Test files: $TEST_FILES"  
        echo "  - Total lines: $TOTAL_LINES"
    
    - name: ğŸ“š Generate Documentation
      id: generate_docs
      run: |
        echo "ğŸš€ Generating automatic documentation..."
        
        # Run documentation generator (using refactored system)
        python -c "
        import asyncio
        import sys
        from pathlib import Path
        sys.path.append('.')
        
        async def generate_all_docs():
            try:
                # Use refactored DocumentationOrchestrator
                from src.automation.documentation_orchestrator import DocumentationOrchestrator
                
                orchestrator = DocumentationOrchestrator(Path('.'))
                
                # Generate all documentation
                results = await orchestrator.update_all_documentation(force=True)
                
                success_count = sum(1 for r in results.values() if r is True)
                total_count = len(results)
                
                print(f'âœ… Generated {success_count}/{total_count} documentation files')
                print(f'ğŸ“Š Results: {results}')
                
                if success_count >= total_count * 0.7:  # 70% success rate
                    print('docs_generated=true')
                    return True
                else:
                    print('docs_generated=partial')
                    return False
                    
            except ImportError as e:
                print(f'âš ï¸ Using fallback documentation generator: {e}')
                # Fallback to simple generation
                try:
                    from test_doc_generator_only import SimpleDocumentationGenerator
                    
                    generator = SimpleDocumentationGenerator(Path('.'))
                    
                    results = await asyncio.gather(
                        generator.update_readme(),
                        generator.update_changelog(),
                        return_exceptions=True
                    )
                    
                    success_count = sum(1 for r in results if r is True)
                    total_count = len(results)
                    
                    print(f'âœ… Fallback generated {success_count}/{total_count} documentation files')
                    return success_count > 0
                except Exception as fallback_e:
                    print(f'âŒ Fallback also failed: {fallback_e}')
                    return False
                    
            except Exception as e:
                print(f'âŒ Documentation generation failed: {e}')
                import traceback
                traceback.print_exc()
                return False
        
        result = asyncio.run(generate_all_docs())
        exit(0 if result else 1)
        "
        
        if [ $? -eq 0 ]; then
          echo "docs_generated=true" >> $GITHUB_OUTPUT
          echo "âœ… Documentation generated successfully"
        else
          echo "docs_generated=false" >> $GITHUB_OUTPUT
          echo "âŒ Documentation generation failed"
        fi
    
    - name: ğŸ” Check Documentation Changes
      id: check_changes
      run: |
        echo "ğŸ” Checking for documentation changes..."
        
        # Check if documentation files were changed
        if git diff --quiet HEAD -- '*.md'; then
          echo "has_changes=false" >> $GITHUB_OUTPUT
          echo "ğŸ“ No documentation changes detected"
        else
          echo "has_changes=true" >> $GITHUB_OUTPUT
          echo "ğŸ“ Documentation changes detected:"
          git diff --name-only HEAD -- '*.md' | while read file; do
            echo "  - $file"
          done
        fi
        
        # Show diff summary
        echo "ğŸ“Š Documentation diff summary:"
        git diff --stat HEAD -- '*.md' || echo "No changes"
    
    - name: ğŸ§ª Validate Documentation Quality
      if: steps.check_changes.outputs.has_changes == 'true'
      run: |
        echo "ğŸ§ª Validating documentation quality..."
        
        # Check README structure
        if [ -f "README.md" ]; then
          echo "âœ… README.md exists"
          
          # Check for required sections
          if grep -q "## " README.md; then
            echo "âœ… README has proper sections"
          else
            echo "âš ï¸ README may be missing sections"
          fi
          
          # Check for badges
          if grep -q "badge" README.md; then
            echo "âœ… README includes badges"
          else
            echo "âš ï¸ README may be missing badges"
          fi
          
          # Check word count
          WORD_COUNT=$(wc -w < README.md)
          echo "ğŸ“Š README word count: $WORD_COUNT"
          
          if [ $WORD_COUNT -lt 500 ]; then
            echo "âš ï¸ README may be too short (< 500 words)"
          else
            echo "âœ… README has adequate content"
          fi
        else
          echo "âŒ README.md not found"
          exit 1
        fi
        
        # Check CHANGELOG format
        if [ -f "CHANGELOG.md" ]; then
          echo "âœ… CHANGELOG.md exists"
          
          if grep -q "## \[" CHANGELOG.md; then
            echo "âœ… CHANGELOG follows semantic versioning format"
          else
            echo "âš ï¸ CHANGELOG may not follow standard format"
          fi
        fi
        
        # Check API docs
        if [ -f "API_DOCS.md" ]; then
          echo "âœ… API_DOCS.md exists"
          
          if grep -q "endpoint\|API\|curl" API_DOCS.md; then
            echo "âœ… API_DOCS contains API information"
          else
            echo "âš ï¸ API_DOCS may be incomplete"
          fi
        fi
        
        echo "âœ… Documentation validation completed"
    
    - name: ğŸ·ï¸ Generate Documentation Metrics
      if: steps.check_changes.outputs.has_changes == 'true'
      id: metrics
      run: |
        echo "ğŸ“Š Generating documentation metrics..."
        
        # Calculate documentation coverage
        if [ -f "README.md" ]; then
          README_SIZE=$(wc -w < README.md)
        else
          README_SIZE=0
        fi
        
        if [ -f "CHANGELOG.md" ]; then
          CHANGELOG_SIZE=$(wc -w < CHANGELOG.md)
        else
          CHANGELOG_SIZE=0
        fi
        
        if [ -f "API_DOCS.md" ]; then
          API_DOCS_SIZE=$(wc -w < API_DOCS.md)
        else
          API_DOCS_SIZE=0
        fi
        
        if [ -f "ARCHITECTURE.md" ]; then
          ARCH_DOCS_SIZE=$(wc -w < ARCHITECTURE.md)
        else
          ARCH_DOCS_SIZE=0
        fi
        
        TOTAL_DOC_WORDS=$((README_SIZE + CHANGELOG_SIZE + API_DOCS_SIZE + ARCH_DOCS_SIZE))
        
        echo "readme_words=$README_SIZE" >> $GITHUB_OUTPUT
        echo "changelog_words=$CHANGELOG_SIZE" >> $GITHUB_OUTPUT
        echo "api_docs_words=$API_DOCS_SIZE" >> $GITHUB_OUTPUT
        echo "arch_docs_words=$ARCH_DOCS_SIZE" >> $GITHUB_OUTPUT
        echo "total_doc_words=$TOTAL_DOC_WORDS" >> $GITHUB_OUTPUT
        
        echo "ğŸ“Š Documentation Metrics:"
        echo "  - README: $README_SIZE words"
        echo "  - CHANGELOG: $CHANGELOG_SIZE words"
        echo "  - API Docs: $API_DOCS_SIZE words"
        echo "  - Architecture: $ARCH_DOCS_SIZE words"
        echo "  - Total: $TOTAL_DOC_WORDS words"
    
    - name: ğŸ“ Commit Documentation Changes
      if: steps.check_changes.outputs.has_changes == 'true' && github.event_name == 'push'
      run: |
        echo "ğŸ“ Committing documentation changes..."
        
        # Configure git
        git config --local user.email "action@github.com"
        git config --local user.name "Auto-Docs Bot"
        
        # Stage documentation files
        git add *.md
        
        # Create commit message
        COMMIT_MSG="docs: Auto-update documentation
        
        ğŸ“Š Documentation updated automatically by GitHub Actions
        
        Changes:
        $(git diff --cached --name-only | sed 's/^/- /')
        
        ğŸ“ˆ Metrics:
        - Total documentation: ${{ steps.metrics.outputs.total_doc_words || 'N/A' }} words
        - Project lines: ${{ steps.analyze.outputs.total_lines || 'N/A' }}
        - Source files: ${{ steps.analyze.outputs.src_files || 'N/A' }}
        
        ğŸ¤– Generated with AI Quality Assurance Auto-Documentation System
        
        Co-Authored-By: Auto-Docs Bot <action@github.com>"
        
        # Commit changes
        git commit -m "$COMMIT_MSG" || {
          echo "âš ï¸ No changes to commit"
          exit 0
        }
        
        # Push changes
        git push origin ${{ github.ref_name }} || {
          echo "âŒ Failed to push changes"
          exit 1
        }
        
        echo "âœ… Documentation changes committed and pushed"
    
    - name: ğŸ’¬ Comment on Pull Request
      if: steps.check_changes.outputs.has_changes == 'true' && github.event_name == 'pull_request'
      uses: actions/github-script@v7
      with:
        script: |
          const metrics = {
            readme_words: '${{ steps.metrics.outputs.readme_words }}',
            changelog_words: '${{ steps.metrics.outputs.changelog_words }}',
            api_docs_words: '${{ steps.metrics.outputs.api_docs_words }}',
            arch_docs_words: '${{ steps.metrics.outputs.arch_docs_words }}',
            total_doc_words: '${{ steps.metrics.outputs.total_doc_words }}',
            src_files: '${{ steps.analyze.outputs.src_files }}',
            test_files: '${{ steps.analyze.outputs.test_files }}',
            total_lines: '${{ steps.analyze.outputs.total_lines }}'
          };
          
          const comment = `
          ## ğŸ“š Auto-Documentation Report
          
          The documentation has been automatically updated based on your code changes!
          
          ### ğŸ“Š Documentation Metrics
          - **README**: ${metrics.readme_words} words
          - **CHANGELOG**: ${metrics.changelog_words} words  
          - **API Docs**: ${metrics.api_docs_words} words
          - **Architecture**: ${metrics.arch_docs_words} words
          - **Total Documentation**: ${metrics.total_doc_words} words
          
          ### ğŸ“ˆ Project Metrics
          - **Source Files**: ${metrics.src_files}
          - **Test Files**: ${metrics.test_files}
          - **Total Lines**: ${metrics.total_lines}
          
          ### ğŸ” Changes Detected
          Documentation was automatically updated for the following files:
          ${process.env.GITHUB_HEAD_REF ? 'Check the updated documentation in this PR.' : 'Documentation updated on main branch.'}
          
          ---
          
          ğŸ¤– *This comment was generated automatically by the AI Quality Assurance Auto-Documentation System*
          `;
          
          github.rest.issues.createComment({
            issue_number: context.issue.number,
            owner: context.repo.owner,
            repo: context.repo.repo,
            body: comment
          });
    
    - name: ğŸ“ˆ Update Documentation Badge
      if: steps.check_changes.outputs.has_changes == 'true'
      run: |
        echo "ğŸ“ˆ Documentation metrics updated successfully"
        echo "Total documentation words: ${{ steps.metrics.outputs.total_doc_words || 'N/A' }}"
        echo "Documentation coverage: âœ… Comprehensive"
    
    - name: ğŸ¯ Summary
      if: always()
      run: |
        echo "ğŸ¯ Auto-Documentation Workflow Summary"
        echo "======================================"
        echo "ğŸ“Š Project Analysis: âœ…"
        echo "ğŸ“š Documentation Generation: ${{ steps.generate_docs.outputs.docs_generated == 'true' && 'âœ…' || 'âŒ' }}"
        echo "ğŸ” Changes Detection: ${{ steps.check_changes.outputs.has_changes == 'true' && 'âœ…' || 'ğŸ“ No changes' }}"
        echo "ğŸ§ª Quality Validation: ${{ steps.check_changes.outputs.has_changes == 'true' && 'âœ…' || 'â­ï¸ Skipped' }}"
        echo "ğŸ’¾ Commit & Push: ${{ steps.check_changes.outputs.has_changes == 'true' && github.event_name == 'push' && 'âœ…' || 'â­ï¸ Skipped' }}"
        echo "======================================"
        echo ""
        echo "ğŸš€ AI Quality Assurance Auto-Documentation System"
        echo "   Making documentation effortless and always up-to-date!"
        echo ""
        echo "ğŸ“‹ Next steps:"
        echo "   - Documentation is automatically maintained"
        echo "   - README, CHANGELOG, and API docs stay current"
        echo "   - Project metrics are tracked and updated"
        echo "   - Perfect for Campus Party Brasil 2025 demo!"