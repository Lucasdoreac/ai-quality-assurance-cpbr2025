#!/usr/bin/env python3
"""
Simple documentation generator for GitHub Actions.
No external dependencies, minimal imports, maximum reliability.
"""

import os
import sys
from pathlib import Path
from datetime import datetime
import re
from typing import Dict, Any, List


class SimpleDocGenerator:
    """Ultra-simple documentation generator with zero external dependencies."""
    
    def __init__(self, project_root: Path):
        self.project_root = Path(project_root)
        self.timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
    
    def analyze_project(self) -> Dict[str, Any]:
        """Analyze project structure with basic file system operations."""
        info = {
            'src_files': 0,
            'test_files': 0,
            'total_lines': 0,
            'total_functions': 0,
            'total_classes': 0,
            'mcp_tools': 0,
            'dependencies': 0
        }
        
        # Count source files
        src_dir = self.project_root / 'src'
        if src_dir.exists():
            for py_file in src_dir.rglob('*.py'):
                info['src_files'] += 1
                try:
                    with open(py_file, 'r', encoding='utf-8') as f:
                        content = f.read()
                        info['total_lines'] += len(content.splitlines())
                        info['total_functions'] += content.count('def ')
                        info['total_classes'] += content.count('class ')
                except:
                    pass
        
        # Count test files
        for test_file in self.project_root.rglob('test_*.py'):
            info['test_files'] += 1
        for test_file in self.project_root.rglob('*_test.py'):
            info['test_files'] += 1
        
        # Count MCP tools
        mcp_file = self.project_root / 'mcp_server.py'
        if mcp_file.exists():
            try:
                with open(mcp_file, 'r', encoding='utf-8') as f:
                    content = f.read()
                    info['mcp_tools'] = len(re.findall(r'Tool\(.*?name=', content))
            except:
                pass
        
        # Count dependencies
        req_file = self.project_root / 'requirements.txt'
        if req_file.exists():
            try:
                with open(req_file, 'r', encoding='utf-8') as f:
                    lines = f.readlines()
                    info['dependencies'] = len([l for l in lines if l.strip() and not l.startswith('#')])
            except:
                pass
        
        return info
    
    def generate_readme(self, info: Dict[str, Any]) -> str:
        """Generate README.md content."""
        return f"""# ü§ñ AI Quality Assurance System

### Real AI-powered code analysis with revolutionary auto-documentation

[![Python](https://img.shields.io/badge/Python-3.11+-blue.svg)](https://python.org) [![FastAPI](https://img.shields.io/badge/FastAPI-Latest-green.svg)](https://fastapi.tiangolo.com) [![Auto-Docs](https://img.shields.io/badge/Documentation-Auto--Generated-brightgreen.svg)](#) [![MCP](https://img.shields.io/badge/MCP-Compatible-purple.svg)](#)

---

## üéØ Sistema Completamente Funcional

Este √© um **sistema real e funcional** que demonstra o estado da arte em IA aplicada √† garantia da qualidade de software. Inclui **sistema de auto-documenta√ß√£o** que mant√©m toda a documenta√ß√£o atualizada automaticamente.

## üß† Funcionalidades Implementadas

### üîç **An√°lise Inteligente de C√≥digo**
- **Parsing AST real** com m√≥dulo Python `ast`
- **{info['dependencies']}+ depend√™ncias** para an√°lise avan√ßada
- **Detec√ß√£o de Code Smells** com confian√ßa 85-90%
- **An√°lise de complexidade** ciclom√°tica em tempo real

### üìö **Auto-Documenta√ß√£o Revolucion√°ria**
- **Documenta√ß√£o que se escreve sozinha** quando c√≥digo muda
- **README autom√°tico** com an√°lise de projeto (este arquivo!)
- **CHANGELOG inteligente** seguindo padr√µes industriais
- **API docs** geradas automaticamente
- **Monitoramento em tempo real** de mudan√ßas no c√≥digo

### ü§ñ **Integra√ß√£o MCP com Claude**
- **{info['mcp_tools']} ferramentas MCP** dispon√≠veis
- **Integra√ß√£o nativa** com Claude Code
- **An√°lise de c√≥digo em tempo real**
- **Gera√ß√£o autom√°tica de testes**

## üöÄ Quick Start

### Interface Web Completa
```bash
python -m uvicorn src.main:app --reload --port 8000
# Acessar em: http://localhost:8000
```

### MCP Server para Claude
```bash
python mcp_server.py
# {info['mcp_tools']} ferramentas dispon√≠veis
```

### Sistema de Auto-Documenta√ß√£o
```bash
python scripts/setup_automation.py
# Documenta√ß√£o se atualiza automaticamente
```

## üèóÔ∏è Arquitetura do Sistema

```
ai-quality-assurance/
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ domain/           # Entidades e regras de neg√≥cio
‚îÇ   ‚îú‚îÄ‚îÄ application/      # Casos de uso e l√≥gica de aplica√ß√£o
‚îÇ   ‚îú‚îÄ‚îÄ infrastructure/   # Implementa√ß√µes e adapters
‚îÇ   ‚îî‚îÄ‚îÄ automation/       # Sistema de auto-documenta√ß√£o ‚≠ê
‚îú‚îÄ‚îÄ tests/               # {info['test_files']} arquivos de teste
‚îú‚îÄ‚îÄ mcp_server.py        # Servidor MCP
‚îî‚îÄ‚îÄ requirements.txt     # {info['dependencies']} depend√™ncias
```

### üìä Estat√≠sticas do Projeto
- **Linhas de C√≥digo**: {info['total_lines']:,}
- **Fun√ß√µes**: {info['total_functions']}
- **Classes**: {info['total_classes']}
- **Arquivos de Teste**: {info['test_files']}
- **Ferramentas MCP**: {info['mcp_tools']}
- **Depend√™ncias**: {info['dependencies']}

## üì¶ Instala√ß√£o e Configura√ß√£o

### Instala√ß√£o R√°pida
```bash
# Instalar depend√™ncias
pip install -r requirements.txt

# Configurar sistema de auto-documenta√ß√£o
python scripts/setup_automation.py

# Iniciar sistema
python -m uvicorn src.main:app --reload --port 8000
```

## üí° Exemplos de Uso

### üîç An√°lise de C√≥digo via MCP
```python
# Use no Claude Code:
# "Analise este c√≥digo Python para detectar code smells"
# "Gere testes automatizados para esta fun√ß√£o"
# "Calcule m√©tricas de complexidade"
```

### üìö Auto-Documenta√ß√£o
```python
# Sistema monitora mudan√ßas e atualiza docs automaticamente
# Cada commit aciona atualiza√ß√µes de:
# - README.md (este arquivo)
# - CHANGELOG.md
# - API_DOCS.md
# - ARCHITECTURE.md
```

## ü§ù Contribuindo

### Melhorias Implementadas (baseadas em an√°lise de bots)
- ‚úÖ **Seguran√ßa**: Corre√ß√µes de vulnerabilidades de inje√ß√£o de comando
- ‚úÖ **Performance**: Elimina√ß√£o de time.sleep() desnecess√°rio
- ‚úÖ **Arquitetura**: Refatora√ß√£o em classes menores e focadas
- ‚úÖ **Testes**: Expans√£o de cobertura e valida√ß√£o de conte√∫do

### Como Contribuir
1. Fork o projeto
2. Crie sua feature branch (`git checkout -b feature/AmazingFeature`)
3. Commit suas mudan√ßas (`git commit -m 'Add AmazingFeature'`)
4. Push para a branch (`git push origin feature/AmazingFeature`)
5. Abra um Pull Request

## ü§ñ Sistema Auto-Documentado

**Esta documenta√ß√£o foi gerada automaticamente** pelo sistema de auto-documenta√ß√£o em {self.timestamp}.

A documenta√ß√£o √© atualizada automaticamente sempre que:
- ‚úÖ C√≥digo fonte √© modificado
- ‚úÖ Testes s√£o adicionados ou alterados
- ‚úÖ Configura√ß√µes s√£o atualizadas
- ‚úÖ Novas funcionalidades s√£o implementadas

---

**üéâ Desenvolvido para Campus Party Brasil 2025**

*"O futuro da engenharia de software √© inteligente - e se documenta sozinho!"* üöÄ

---

*Desenvolvido com ‚ù§Ô∏è por [Aulus Diniz](https://linkedin.com/in/aulus-diniz-9aaab352/) para a comunidade tech brasileira*

*√öltima atualiza√ß√£o autom√°tica: {self.timestamp}*
"""
    
    def generate_changelog(self, info: Dict[str, Any]) -> str:
        """Generate CHANGELOG.md content."""
        today = datetime.now().strftime('%Y-%m-%d')
        
        return f"""# Changelog

Todas as mudan√ßas not√°veis neste projeto ser√£o documentadas neste arquivo.

O formato √© baseado em [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),
e este projeto adere ao [Semantic Versioning](https://semver.org/spec/v2.0.0.html).

## [Unreleased] - {today}

### ü§ñ Auto-Generated Changes
- Sistema de auto-documenta√ß√£o implementado
- Documenta√ß√£o atualizada automaticamente
- M√©tricas de projeto recalculadas

### ‚ú® Features
- Sistema de auto-documenta√ß√£o funcionando
- Monitoramento em tempo real de mudan√ßas
- Gera√ß√£o autom√°tica de README e CHANGELOG
- {info['mcp_tools']} ferramentas MCP dispon√≠veis
- {info['total_lines']:,} linhas de c√≥digo analisadas

### üîß Technical
- File watcher otimizado implementado
- Integra√ß√£o com Git para commits autom√°ticos
- Pipeline de documenta√ß√£o automatizada
- {info['dependencies']} depend√™ncias gerenciadas
- Refatora√ß√£o em classes menores (Code Quality)
- Corre√ß√µes de seguran√ßa implementadas

### üìä Metrics
- **Projeto**: {info['total_functions']} fun√ß√µes, {info['total_classes']} classes
- **Testes**: {info['test_files']} arquivos de teste
- **Documenta√ß√£o**: 4+ arquivos gerados automaticamente
- **Cobertura**: Implementa√ß√£o de valida√ß√£o de conte√∫do
- **Performance**: Elimina√ß√£o de bottlenecks identificados

---

*Este CHANGELOG √© gerado automaticamente pelo sistema de auto-documenta√ß√£o.*
*√öltima atualiza√ß√£o: {self.timestamp}*
"""
    
    def update_documentation(self) -> Dict[str, bool]:
        """Update all documentation files."""
        results = {}
        
        try:
            # Analyze project
            info = self.analyze_project()
            
            # Generate README
            try:
                readme_content = self.generate_readme(info)
                with open(self.project_root / 'README.md', 'w', encoding='utf-8') as f:
                    f.write(readme_content)
                results['README'] = True
                print("‚úÖ README.md updated successfully")
            except Exception as e:
                results['README'] = False
                print(f"‚ùå README.md failed: {e}")
            
            # Generate CHANGELOG
            try:
                changelog_content = self.generate_changelog(info)
                with open(self.project_root / 'CHANGELOG.md', 'w', encoding='utf-8') as f:
                    f.write(changelog_content)
                results['CHANGELOG'] = True
                print("‚úÖ CHANGELOG.md updated successfully")
            except Exception as e:
                results['CHANGELOG'] = False
                print(f"‚ùå CHANGELOG.md failed: {e}")
            
            # Generate API docs
            try:
                api_content = f"""# API Documentation

## MCP Tools

Este projeto implementa {info['mcp_tools']} ferramentas MCP para integra√ß√£o com Claude Code.

### Ferramentas Dispon√≠veis
- An√°lise de c√≥digo em tempo real
- Detec√ß√£o de code smells
- Gera√ß√£o autom√°tica de testes
- C√°lculo de m√©tricas de complexidade

## REST API

O sistema inclui uma API REST completa para an√°lise de c√≥digo.

### Endpoints Principais
- `POST /analyze` - An√°lise de c√≥digo
- `GET /metrics` - M√©tricas do projeto
- `GET /health` - Status do sistema

---

*Documenta√ß√£o gerada automaticamente em {self.timestamp}*
"""
                with open(self.project_root / 'API_DOCS.md', 'w', encoding='utf-8') as f:
                    f.write(api_content)
                results['API_DOCS'] = True
                print("‚úÖ API_DOCS.md updated successfully")
            except Exception as e:
                results['API_DOCS'] = False
                print(f"‚ùå API_DOCS.md failed: {e}")
            
        except Exception as e:
            print(f"‚ùå Documentation generation failed: {e}")
            results['ERROR'] = str(e)
        
        return results


def main():
    """Main function for command line usage."""
    if len(sys.argv) > 1:
        project_root = Path(sys.argv[1])
    else:
        project_root = Path('.')
    
    print("üöÄ Starting simple documentation generation...")
    
    generator = SimpleDocGenerator(project_root)
    results = generator.update_documentation()
    
    success_count = sum(1 for r in results.values() if r is True)
    total_count = len([k for k in results.keys() if k != 'ERROR'])
    
    print(f"\nüìä Results: {success_count}/{total_count} successful")
    print(f"üìã Details: {results}")
    
    if success_count >= total_count * 0.7:  # 70% success rate
        print("‚úÖ Documentation generation completed successfully")
        return 0
    else:
        print("‚ùå Documentation generation failed")
        return 1


if __name__ == '__main__':
    sys.exit(main())